<div dir="rtl">

# آزمایش ششم - آز نرم 

## گزارش 

### Abstract Factory:
برای پیاده‌سازی این الگو به روش TDD، ابتدا JUnit را به dependencies اضافه کردیم تا بتوانیم با نوشتن تست برای پروژه 
شروع به کار کنیم.

ابتدا یک تست برای بررسی متد createTree از کلاس PersianGardenFactory نوشتیم که چک می‌کرد مقدار بازگشتی این تابع از 
نوع Chenar باشد. برای اجرای این تست نیاز به کلاس‌های زیر بود:

1. AbstractGardenFactory
2. AbstractTree
3. PersianGardenFactory
4. Chenar

که کلاس سوم، کلاس اول را پیاده‌سازی می‌کرد و کلاس چهارم، کلاس دوم را.

این کلاس‌ها به پروژه اضافه شدند و تست اول موفقیت‌آمیز بود.
در تست دوم، چک کردیم مقدار بازگشتی متد createFlower از کلاس PersianGardenFactory از نوع Khatmi باشد. برای این کار 
نیاز بود یک متد جدید در کلاس AbstractGardenFactory ساخته شود و سپس در PersianGardenFactory پیاده‌سازی شود، و همچنین 
دو کلاس جدید زیر نیز به پروژه اضافه شوند:

1. AbstractFlower
2. Khatmi

پس از اضافه کردن کد لازم، تست دوم نیز موفقیت‌آمیز بود و سراغ تست سوم رفتیم. در این تست ساخته شدن درخت Maple در کلاس 
JapaneseGardenFactory چک می‌شد که برای آن نیاز به ساخت دو کلاس جدید بود:

1. JapaneseGardenFactory
2. Maple

که اولی AbstractGardenFactory و دومی AbstractTree را پیاده‌سازی می‌کنند. در نهایت پس از اجرای موفقیت‌آمیز این تست 
نیز آخرین تست نوشته شد که ساخته شدن گل Sakura را در JapaneseGardenFactory تست می‌کرد. در این کلاس متد createFlower 
از قبل وجود داشت، زیرا این متد را به AbstractGardenFactory اضافه کرده بودیم و در این کلاس نیاز بود آن را پیاده‌سازی 
کنیم؛ اما مقدار بازگشتی آن null بود، و برای پاس کردن تست آخر کلاس Sakura را ساختیم که AbstractFlower را پیاده‌سازی 
می‌کرد و این متد را کامل کردیم.

در نهایت هر ۴ تست با موفقیت پاس شدند و این قسمت از پروژه تکمیل شد.

***
### Prototype:
در این قسمت باز به روش TDD، در هر مرحله ابتدا تست‌ها نوشته شدند و سپس کد مورد نیاز برای آنها اضافه شد.

یک کلاس abstract به نام Prototype داریم که دو متد درون آن است، یکی متد clone که برای کپی گرفتن استفاده می‌شود و 
دیگری متد getName برای آنکه بدانیم در درون شی‌های این کلاس، مقدار attributeها چگونه است (فرض شد که همه‌ی فرزندان یک 
attribute به نام name دارند).

سپس دو کلاس PlanePrototype و HelicopterPrototype ساخته شدند که پیش از آن برای هرکدام تست نوشته شده بود و در هرکدام 
متدهای clone و getName پیاده‌سازی شدند. (در واقع ابتدا تست برای کلاس PlanePrototype نوشته شد و این کلاس و خود کلاس 
Prototype ابتدا به پروژه اضافه شدند و سپس تست برای کلاس دیگر نوشته شد و آن نیز به پروژه اضافه شد. در تست‌ها نیز چک 
کردیم که اشیا ساخته شده یکسان نباشند، اما مقدار attribute یکسان داشته باشند؛ یعنی کپی هم باشند).

***
### Builder:
برای این الگو، یک تست نوشته شد که در آن یک Builder ساخته می‌شود، به constructor یک Director پاس داده می‌شود تا یک 
دایرکتور نیز ساخته شود و درون آن دایرکتور با استفاده از متد constructBow یک شی از نوع Weapon ساخته می‌شود که مقادیر 
مشخصی برای هر attribute در آن در نظر گرفته شده است.
سپس کد مربوطه برای اجرای موفق این تست پیاده‌سازی شد:
1. یک کلاس Builder که متدهایی برای ذخیره مقدار attributeهای لازم برای ساخت یک Weapon نیاز است و یک متد برای ساخت آن 
   دارد.
2. یک کلاس Director که یک متد constructBow دارد که مشخصات یک bow را به Builder پاس می‌دهد.
3. در نهایت یک کلاس Weapon که تعدادی attribute دارد.

بعد از این، یک تست دیگر نیز اضافه شد برای ساخت یک نمونه‌ی دیگر از کلاس Weapon که attributeهای متفاوت با قبلی دارد، و 
برای این تست نیز تنها لازم بود که یک متد به Director اضافه شود: constructSword



## پاسخ به پرسش‌ها
   **در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.**
   
   الگوهای ساختی، ساختاری و رفتاری
   الگوهای ساختی (creational)، الگوهایی هستند که در رابطه با ساخت نمونه‌های مختلف از کلاس‌ها (یا همان اشیا) سر و کار دارند.
   الگوهای ساختاری (structural)، الگوهایی هستند که برای ساختار کلاس‌ها مثل ارث‌بری و... قواعدی تعریف می‌کنند.
   الگوهای رفتاری (behavioral)، الگوهایی هستند که در روابط و تعاملات بین اشیا تعریف می‌شوند.
   
   
***
   **سه الگوی استفاده شده در این آزمایش جزو کدام دسته هستند؟**
   
   هر سه از نوع ساختی (همان creational) هستند.
   
***
   
   **فرق اصلی پنج اصل SOLID با الگوهای طراحی مطرح‌شده در GoF چیست؟**
   
   اصول SOLID بسیار کلی هستند و در همه جای یک پروژه‌ی نرم‌افزاری کاربرد دارند؛ در حالی که الگوهای مطرح شده در GoF به صورت موردی هستند و ممکن است در بعضی مثال‌ها کاربرد داشته باشند و در برخی دیگر خیر.
   
***
   
   **آیا الگوی طراحی Singleton موردی از اصول SOLID را نقض می‌کند؟ توضیح دهید.**
   
   بله، اصل open / closed را نقض می‌کند. زیرا اگر قابلیت ارث‌بری را اجازه بدهد، دیگر singleton نیست و امکان وجود چند نمونه از این کلاس به وجود می‌آید (زیرا فرزندان آن هم نمونه‌هایی از خودش هستند)؛ پس مجبور است اجازه‌ی ارث‌بری از خود را ندهد و این باعث می‌شود که open نباشد (امکان توسعه‌ی آن از بین می‌رود).  
   
